---
title: TypeScriptè®­ç»ƒ
date: 2023-05-05 08:56:57
# permalink: /pages/ts-challenges/
categories:
  - å‰ç«¯
  - å­¦ä¹ ç¬”è®°
tags:
  - TypeScript
author:
  name: HokageYeah
  link: https://github.com/HokageYeah
---







## è¯´åœ¨å‰é¢
è®­ç»ƒé¢˜ç›®æ¥æº [tsè®­ç»ƒè¥](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)ï¼Œå…³äºæ ‡è®°

- :tomato: æˆ–è€… :package: è¡¨ç¤ºæ˜¯éš¾é¢˜
- :question:  è¡¨ç¤ºé‡ç‚¹æˆ–è€…æ˜¯è¿˜æœ‰ç–‘é—®
- :x: è¡¨ç¤ºé¢˜ç›®æœªå¤„ç†
- :thinking: è¡¨ç¤ºé¢˜ç›®å€¼å¾—æ€è€ƒ
- :tea: è¡¨ç¤ºé¢˜ç›®å€¼å¾—æ”¾æ¾ä¸€ä¸‹
- å…¶ä»–ç¬¦å·æ²¡ä»€ä¹ˆå«ä¹‰ ,ä¹Ÿå¯èƒ½æœ‰å€¼å¾—æ ‡æ³¨çš„åœ°æ–¹ï¼Ÿå—¯... ã€æˆ‘è‚¯å®šæ˜¯è¿™æ ·è®¤ä¸ºçš„ã€‘


---

[[toc]]

---





# ä¸€ã€ç®€å•





##  æ··åˆ

å®ç° Pick

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
```

::: tip

- in
- keyof
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyPick<T, K extends keyof T> = {

    [key in K]: T[key]

}
```

:::



### å®ç°å…ƒç»„è½¬æ¢å¯¹è±¡

ä¼ å…¥ä¸€ä¸ªå…ƒç»„ç±»å‹ï¼Œå°†è¿™ä¸ªå…ƒç»„ç±»å‹è½¬æ¢ä¸ºå¯¹è±¡ç±»å‹ï¼Œè¿™ä¸ªå¯¹è±¡ç±»å‹çš„é”®/å€¼éƒ½æ˜¯ä»å…ƒç»„ä¸­éå†å‡ºæ¥ã€‚

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```



::: danger é”™è¯¯ç¤ºä¾‹

:::

::: details

```ts
type TupleToObject<T extends any[]> = {
    [K in T[number]]: K
}
```

:::


::: tip æ­£ç¡®ç­”æ¡ˆ

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type TupleToObject<T extends (number | symbol | string)[]> = {
    [K in T[number]]: K
}
```

:::








### å®ç° exclude

::: tip

- never
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyExclude<T, U> = U extends T ? never : T
```

:::

### å®ç° Include

::: tip

- never
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyInclude<T, U> = U extends T ? T : never
```

:::

### å®ç° If

å®ç°ä¸€ä¸ª `IF` ç±»å‹ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªæ¡ä»¶ç±»å‹ `C` ï¼Œä¸€ä¸ªåˆ¤æ–­ä¸ºçœŸæ—¶çš„è¿”å›ç±»å‹ `T` ï¼Œä»¥åŠä¸€ä¸ªåˆ¤æ–­ä¸ºå‡æ—¶çš„è¿”å›ç±»å‹ `F`ã€‚ `C`
åªèƒ½æ˜¯ `true` æˆ–è€… `false`ï¼Œ `T` å’Œ `F` å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚

example

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

::: tip

- boolean
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type If<T extends boolean, U, P> = T extends true ? U : P
```

:::








## æ•°ç»„ç³»åˆ—


### å®ç° First

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type First<T extends any[]> = T extends [infer F, ...infer] ? F : []
```

:::

### å®ç° End

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = End<arr1> // expected to be 'c'
type head2 = End<arr2> // expected to be 1
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type End<T extends any[]> = T extends [...infer, infer E] ? E : []
```

:::

### å®ç° Unshitf

```ts

type Result = Unshift<[1, 2], 0> // [0, 1, 2]

```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

:::



### å®ç° Shitf

```ts
type Result = Shift<[1, 2, 2, 3]> // [2,3,3]

```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Shift<T extends any[]> = T extends [infer L,...infer R]?R:T
```

:::

### å®ç° Push

```ts

type Result = Push<[1, 2], 0> // [1,2,0]

```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Push<T extends any[], U> = [...T, U]
```

:::

### è·å– Length

åˆ›å»ºä¸€ä¸ªé€šç”¨çš„`Length`ï¼Œæ¥å—ä¸€ä¸ª`readonly`çš„æ•°ç»„ï¼Œè¿”å›è¿™ä¸ªæ•°ç»„çš„é•¿åº¦ã€‚

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

::: tip

- extends
- tsä¸­è·å–æ•°ç»„è·å–é•¿åº¦çš„æ–¹å¼

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Length<T extends readonly any[]> = T['length']
```

:::



### å®ç° concat

::: tip

æ•°ç»„çš„è§£æ„èµ‹å€¼

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
```

:::





### å®ç° Reverse

```ts
type A = Reverse<[1, 2, 3, 4]> // [4, 3, 2, 1]
```



::: tip æ„é€ ä¸€ä¸ªæ•°ç»„å­˜æ”¾åè½¬æ•°ç»„

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// è§£æ³•ä¸€
type Reverse<T extends any[], U extends any[] = []> = T extends [...infer L, infer R] ? Reverse<L, [...U, R]> : U

// è§£æ³•äºŒ
type Reverse<T extends any[]> = T extends [...infer F, infer R] ? [R, ...Reverse<F>] : T
```

:::





### :package: å®ç° LastIndexOf



å®ç°Array.lastIndexOfçš„ç±»å‹ç‰ˆæœ¬ï¼ŒlastIndexOf<Tï¼ŒU>è·å–æ•°ç»„Tï¼Œä»»æ„Uï¼Œå¹¶è¿”å›æ•°ç»„Tä¸­æœ€åä¸€ä¸ªUçš„ç´¢å¼•

```ts
type Res1 = LastIndexOf<[1, 2, 3, 2, 1], 2> // 3
type Res2 = LastIndexOf<[0, 0, 0], 2> // -1
```



::: tip é€’å½’éå†æ•´ä¸ªæ•°ç»„ï¼Œä½¿ç”¨å˜é‡ä¿å­˜ä¸‹æ ‡

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type LastIndexOf<T extends any[], U extends number, M extends number = -1, N extends any[] = []> =
  T extends [infer A, ...infer B]
  ? A extends U
  ? LastIndexOf<B, U, N['length'], [...N, 0]> : LastIndexOf<B, U, M, [...N, 0]>
  : M


```

:::





### :package: å®ç° Combination





```ts
// expected to be `"foo" | "bar" | "baz" | "foo bar" | "foo bar baz" | "foo baz" | "foo baz bar" | "bar foo" | "bar foo baz" | "bar baz" | "bar baz foo" | "baz foo" | "baz foo bar" | "baz bar" | "baz bar foo"`
type Keys = Combination<['foo', 'bar', 'baz']>
```



::: tip é€’å½’éå†æ•´ä¸ªæ•°ç»„

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsExist<T extends any[], O> =
  T extends [infer L, ...infer R]
  ? L extends O ? true : IsExist<R, O> : false



type Unique<T extends any[], N extends any[] = []> =
  T extends [infer L, ...infer R] ?
  IsExist<N, L> extends false ? Unique<R, [...N, L]>
  : Unique<R, N> : N


```

:::





### :package: å®ç° Filter





```ts
type Filtered = FilterOut<[1, 2, null, 3], null> // [1, 2, 3]
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

type FilterOut<T extends any[], U> = T extends [infer L, ...infer Rest] ? [L] extends [U] ? [...FilterOut<Rest, U>] : [L, ...FilterOut<Rest, U>] : T

```

:::



[æœ¬é¢˜è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27566)





### å®ç° Unique



æ•°ç»„å»é‡

```ts
type Res = Unique<[1, 1, 2, 2, 3, 3]>; // expected to be [1, 2, 3]
type Res1 = Unique<[1, 2, 3, 4, 4, 5, 6, 7]>; // expected to be [1, 2, 3, 4, 5, 6, 7]
type Res2 = Unique<[1, "a", 2, "b", 2, "a"]>; // expected to be [1, "a", 2, "b"]
type Res3 = Unique<[string, number, 1, "a", 1, string, 2, "b", 2, number]>; // expected to be [string, number, 1, "a", 2, "b"]
type Res4 = Unique<[unknown, unknown, any, any, never, never]>; // expected to be [unknown, any, never]
```



::: tip é€’å½’éå†æ•´ä¸ªæ•°ç»„

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsExist<T extends any[], O> =
  T extends [infer L, ...infer R]
  ? L extends O ? true : IsExist<R, O> : false



type Unique<T extends any[], N extends any[] = []> =
  T extends [infer L, ...infer R] ?
  IsExist<N, L> extends false ? Unique<R, [...N, L]>
  : Unique<R, N> : N


```

:::





### å®ç° GetMiddleElement



å¦‚æœæ˜¯å¥‡æ•°é•¿åº¦ï¼Œå–ä¸­é—´ä¸€ä¸ªæ•°ï¼Œå¦‚æœæ˜¯å¶æ•°ï¼Œå–ä¸­é—´ä¸¤ä¸ªæ•°ã€‚

```ts
type simple1 = GetMiddleElement<[1, 2, 3, 4, 5]> // expected to be [3]
type simple2 = GetMiddleElement<[1, 2, 3, 4, 5, 6]> // expected to be [3, 4]
```



::: tip é€’å½’éå†æ•´ä¸ªæ•°ç»„ï¼Œåˆ¤æ–­é•¿åº¦ä»€ä¹ˆæ—¶å€™å¯ä»¥é€’å½’ç»“æŸï¼›ä»¥åŠä½¿ç”¨inferå¦‚ä½•æå–ä¸­é—´å†…å®¹

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type GetMiddleElement<T extends any[]> =
  T['length'] extends 0 | 1 | 2
  ? T : T extends [any, ...infer R, any] ? GetMiddleElement<R> :never
```

:::





### å®ç° Appear only once



æŸ¥æ‰¾ç›®æ ‡æ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ ã€‚ä¾‹å¦‚ï¼šè¾“å…¥ï¼š[1ï¼Œ2ï¼Œ3ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ6ï¼Œ6]ï¼Œè¾“å‡ºï¼š[1ï¼Œ4ï¼Œ5]ã€‚

```ts
type simple1 = GetMiddleElement<[1, 2, 3, 4, 5]> // expected to be [3]
type simple2 = GetMiddleElement<[1, 2, 3, 4, 5, 6]> // expected to be [3, 4]
```



::: tip å¯ä»¥ä½¿ç”¨ä¸€ä¸ªè¾…åŠ©ç±»åˆ¤æ–­æ˜¯å¦ä¸€ä¸ªå…ƒç´ æ˜¯å¦é‡å¤ï¼Œé‡å¤ä¸æ·»åŠ ï¼Œåä¹‹æ·»åŠ 

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// è¾…åŠ©ç±» æ˜¯å¦é‡å¤
type IsRepeated<T extends any[], U, N extends any[] = []> =
  T extends [infer L, ...infer R] ? L extends U
  ? IsRepeated<R, U, [...N, L]> : IsRepeated<R, U, N> : N['length'] extends 0 | 1 ? false : true

// ç»“æœ
type UniqueArray<T extends any[], O extends any[] = T, U extends any[] = []> =
  T extends [infer L, ...infer R] ?
  IsRepeated<O, L> extends true ? UniqueArray<R, O, U> : UniqueArray<R, O, [...U, L]> : U
```

:::






### å®ç°æ•°ç»„æ‰å¹³åŒ–

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```
::: tip é€’å½’
:::


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
// è§£æ³•ä¸€
type Flatten<T extends any[], O extends any[] = []> =
  T extends [infer F, ...infer R] ? (
    (F extends any[] ? Flatten<[...F, ...R], O> : Flatten<R, [...O, F]>)
  ) : O

// è§£æ³•äºŒ ä¸ä½¿ç”¨é¢å¤–å‚æ•°
type F<T extends any[]> =
  T extends [infer L, ...infer R]
  ? L extends any[] ? [...F<L>, ...F<R>] : [L, ...F<R>] : T
```
:::



### æŒ‡å®šæ·±åº¦æ‰å¹³åŒ–



```ts
type a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. flattern 2 times
type b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. Depth defaults to be 1
```

::: tip å‚è€ƒæ•°ç»„æ·±åº¦æ‰å¹³åŒ–ï¼Œå¯ä»¥åˆ©ç”¨æ•°ç»„ `length` å±æ€§ï¼Œå®ç°æŒ‡å®šé•¿åº¦åˆ¤æ–­
:::


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// å…ˆå®ç°çœ‹çœ‹ æ·±åº¦é€’å½’æ‰å¹³åŒ–
type FlattenDepth<T extends any[], U extends number = 1, D extends any[] = []> = 
T extends [infer L, ...infer R]
  ? (L extends any[] ? [...FlattenDepth<L, U, [...D, 1]>, ...FlattenDepth<R, U, D>] : [L, ...FlattenDepth<R, U, D>]) : T


// åŠ ä¸Šé•¿åº¦åˆ¤æ–­å°±å¯ä»¥å®ç°æŒ‡å®šæ·±åº¦æ‰å¹³åŒ–äº†
// ç­”æ¡ˆ
type FlattenDepth<T extends any[], U extends number = 1, D extends any[] = []> = 
  D['length'] extends U
  ? T : T extends [infer L, ...infer R]
  ? (L extends any[] ? [...FlattenDepth<L, U, [...D, 1]>, ...FlattenDepth<R, U, D>] : [L, ...FlattenDepth<R, U, D>]) : T
```

:::







### å®ç°æŒ‡å®šåˆ é™¤æ•°ç»„å†…å®¹

```ts
type Res = Without<[1, 2], 1>; // expected to be [2]
type Res1 = Without<[1, 2, 4, 1, 5], [1, 2]>; // expected to be [4, 5]
type Res2 = Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]>; // expected to be []
```



::: tip è§£æ³•æœ‰å¾ˆå¤šï¼Œåˆ¤æ–­å†…å®¹æ˜¯å¦å­˜åœ¨ä¸æŒ‡å®šå†…å®¹ä¸­ï¼Œæˆ–è€…ä½¿ç”¨ è”åˆç±»å‹

:::






::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// è§£æ³•ä¸€ è½¬æ¢æˆè”åˆç±»å‹
type ToUnion<T extends any> = T extends any[] ? T[number] : T
type Without<T extends any[], U extends any | any[]> = T extends [infer L, ...infer R] ?
  L extends ToUnion<U> ? Without<R, U> : [L, ...Without<R, U>] : T

// è§£æ³•äºŒ åˆ¤æ–­æ³• 
type IsExist<R, T extends any | any[]> =
  T extends [infer A, ...infer B] ? R extends A ? true : IsExist<R, B> : R extends T ? true : false


type Without<T extends any[], U, O extends any[] = []> =
  T['length'] extends 0 ? O
  :
  T extends [infer L, ...infer R]
  ?
  IsExist<L, U> extends true ? Without<R, U, O> : Without<R, U, [L, ...O]>
  : O


```

:::



**æ‹“å±•**

- å°è¯•ä½¿ç”¨ `Pop` æˆ–è€… `shift` æ–¹æ³•å®ç°ï¼





### å®ç°ç»™å®šé•¿åº¦çš„æ•°ç»„

```ts
type result = ConstructTuple<2> // expect to be [unknown, unkonwn]
```




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type ConstructTuple<T extends number, R extends any[] = []> = R['length'] extends T ? R : ConstructTuple<T, [...R, unknown]>
```

:::





### :tomato: å®ç°çŸ©é˜µå˜æ¢

```ts
type Matrix = Transpose <[[1]]>; // expected to be [[1]]
type Matrix1 = Transpose <[[1, 2], [3, 4]]>; // expected to be [[1, 3], [2, 4]]
type Matrix2 = Transpose <[[1, 2, 3], [4, 5, 6]]>; // expected to be [[1, 4], [2, 5], [3, 6]]
```




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type ConstructTuple<T extends number, R extends any[] = []> = R['length'] extends T ? R : ConstructTuple<T, [...R, unknown]>
```

:::







##  ReadOnly ç³»åˆ—



### å®ç° Readonly



```ts
interface Todo {
    title: string
    description: string
}

const todo: MyReadonly<Todo> = {
    title: "Hey",
    description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyReadonly<T> = {
    +readonly [key in keyof T]: T[key]
}
```

:::



### :hamburger: å®ç° DeepReadOnly


```ts
type X = {
    name: 'a',
    age: 12,
    b: {
        c: {
            a: 'role'
        }
    }
}

type Expected = {
    readonly x: {
        readonly a: 1
        readonly b: 'hi'
    }
    readonly y: 'hey'
}

```

::: tip

æˆ‘ä¸ªäººæ„Ÿè§‰è¿™ç§å†™æ³•ä¸å¥½ç†è§£

- keyof
- in
- extends
- never

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type DeepReadonly<T> = keyof T extends never ? T : { readonly [k in keyof T]: DeepReadonly<T[k]> };
```

:::





### :hamburger: å®ç° Mutable

å®ç°ä¸€ä¸ªé€šç”¨çš„ç±»å‹ `Mutable<T>`ï¼Œä½¿ç±»å‹ `T` çš„å…¨éƒ¨å±æ€§å¯å˜ï¼ˆéåªè¯»ï¼‰ã€‚



```ts
interface Todo {
  readonly title: string
  readonly description: string
  readonly completed: boolean
}

type MutableTodo = Mutable<Todo> // { title: string; description: string; completed: boolean; }

```



::: tip  **+readonly** è¡¨ç¤ºåªè¯»ï¼Œ **-readonly** è¡¨ç¤ºå¯è¯»å†™

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Mutable<T extends object = {}> = {
  -readonly [key in keyof T]: T[key]
}
```

:::



### :hamburger: å®ç° DeepMutable

å®ç°é€’å½’å¯è¯»å†™



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type DeepReadonly<T> = keyof T extends never ? T : { -readonly [k in keyof T]: DeepReadonly<T[k]> };
```

:::







#  äºŒã€ä¸­ç­‰







## å­—ç¬¦ä¸²



### å®ç°å­—ç¬¦ä¸²é¦–å­—æ¯å¤§å†™



```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```



::: tip `ts` ä¸­å­—ç¬¦ä¸²è½¬æ¢æˆå¤§å†™ `Uppercase`;å°å†™æ˜¯ `Lowercase`

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Capitalize<T extends string> = T extends `${infer F}${infer L}` ? `${Uppercase<F>}${L}` : T 

```

:::



æ‹“å±•

- å®ç° å…¨éƒ¨å¤§å†™
- å®ç° å…¨éƒ¨å°å†™



### å®ç°å­—ç¬¦ä¸²æ›¿æ¢

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // expected to be 'types are awesome!'
```



::: tip ä½¿ç”¨inferæå–ï¼Œéœ€è¦è€ƒè™‘ç©ºå­—ç¬¦ä¸²æƒ…å†µ

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Replace<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}`?  `${L}${T}${R}`: S
)
```

:::



**æ‹“å±•**

å®ç°å…¨å±€æ›¿æ¢

```ts
type replaced = ReplaceAll<'fun types fun are fun!', 'fun', 'awesome'> // expected to be 'awesome types awesome are awesome!'
```



::: tip æ ¹æ®ä¸Šé¢ä½¿ç”¨é€’å½’å°±å¯ä»¥äº†

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type ReplaceAll<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}` ? ReplaceAll<`${L}${T}${R}`, F, T> : S
)
```

:::


### å®ç°è·å–å­—ç¬¦ä¸²é•¿åº¦


::: tip  å­—ç¬¦ä¸²æ˜¯æ˜¯æ— æ³•ç›´æ¥è·å–é•¿åº¦ï¼Œè½¬æ¢æˆæ•°ç»„ï¼Œé€šè¿‡é€’å½’éå†ç„¶åè·å–
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type StrLen<T extends string, Arr extends string[] = []> = T extends `${infer F}${infer R}` ? StrLen<R, [...Arr, F]> : A['length']
```

// eg
type B = StrLen<"javascript"> // 10
:::


### å®ç°å­—ç¬¦ä¸²è½¬æ¢è”åˆç±»å‹

å®ç°ä¸€ä¸ªæ¥æ”¶string,numberæˆ–bigIntç±»å‹å‚æ•°çš„Absoluteç±»å‹,è¿”å›ä¸€ä¸ªæ­£æ•°å­—ç¬¦ä¸²

```ts
type Test = '123';
type Result = StringToUnion<Test>; // expected to be "1" | "2" | "3"
```

::: tip ç”¨inferé€’å½’å¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type StringToUnion<T extends string> = T extends `${infer F}${infer R}` ? F | StringToUnion<R> : never
```
:::





### å®ç°æ˜¯å¦æ˜¯ç»™å®šå­—ç¬¦ä¸²å¼€å¤´

å®ç°StartsWith<T, U>,æ¥æ”¶ä¸¤ä¸ªstringç±»å‹å‚æ•°,ç„¶ååˆ¤æ–­Tæ˜¯å¦ä»¥Uå¼€å¤´,æ ¹æ®ç»“æœè¿”å›trueæˆ–false

```ts
type a = StartsWith<'abc', 'ac'> // expected to be false
type b = StartsWith<'abc', 'ab'> // expected to be true
type c = StartsWith<'abc', 'abcd'> // expected to be false
```


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

type StartsWith<T extends string, U extends string> = T extends `${U}${infer R}` ? true : false
```

:::


**æ‹“å±•**
åˆ¤æ–­æ˜¯å¦æ˜¯æŒ‡å®šå­—ç¬¦ä¸²ç»“å°¾


```ts

type End<T extends string, U extends string> = T extends `${infer R}${U}` ? true : false
```

:::





### å®ç°å»æ‰å­—ç¬¦ä¸²ç©ºæ ¼


```ts
type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  
type trimed1 = TrimRright<'  Hello World  '> // expected to be 'Hello World  
type trimed2 = Trim<'  Hello World  '> // expected to be 'Hello World  
```

::: tip æŠŠå­—ç¬¦ä¸²å½“æ•°ç»„ç†è§£ï¼Œæ•°ç»„æ˜¯å¦‚ä½•æå–ï¼Œå­—ç¬¦ä¸²å°±å¦‚ä½•æå–

- é€’å½’

- infer

:::




::: details æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ä¸€æ¬¡æ€§è§£å†³å§
type S = ' '
type TrimLeft<T extends string> = T extends `${S}${infer R}` ? TrimLeft<R>:T
type TrimRright<T extends string> = T extends `${infer R}${S}` ? TrimRright<R>:T
type Trim<T extends string> = T extends `${S}${infer R}${S}` ? Trim<R>:T
// çœ‹äº†ç­”æ¡ˆs = ' 'ä¸å‡†ç¡®ï¼Œä½¿ç”¨ S = ' ' | '\n' | '\t'
```

:::





### å®ç°åˆ é™¤ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ä¸²

```ts
type Butterfly = DropChar<' b u t t e r f l y ! ', ' '> // 'butterfly!'
```

> é€’å½’ï¼ï¼ï¼æ³¨æ„ä¿å­˜æ¯æ¬¡åˆ é™¤ä¹‹åçš„å€¼

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type DropChar<T extends string, S extends string = ''> = T extends `${infer L}${S}${infer R}`
  ? DropChar<`${L}${R}`, S> : T
```

:::










### :scissors: å®ç°é©¼å³°å‘½åè½¬æ¢çŸ­æ¨ªçº¿å‘½å


```ts
type FooBarBaz = KebabCase<"FooBarBaz">;
const foobarbaz: FooBarBaz = "foo-bar-baz";

type DoNothing = KebabCase<"do-nothing">;
const doNothing: DoNothing = "do-nothing";
type D = Uncapitalize<"FooBarBaz">
```

::: tip ç”¨inferé€’å½’å¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
// ç¬¬ä¸€æ­¥å†™å‡ºåŸºæœ¬å½¢å¼
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? `${Uncapitalize<S1>}${Uncapitalize<S2>}`:S
// åˆ¤æ–­ S2 å¼€å¤´æ˜¯å¦å¤§å†™ï¼Œå¦‚æœæ˜¯å¤§å†™ï¼Œè½¬æ¢æˆå°å†™ï¼ŒåŒæ—¶åœ¨å‰é¢æ·»åŠ çŸ­æ¨ªçº¿ï¼Œ
// é€’å½’ infer æå–çš„ S2
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? (
  S2 extends `${Uncapitalize<S2>}`?  `${Uncapitalize<S1>}${KebabCase<S2>}`: `${Uncapitalize<S1>}-${KebabCase<S2>}`
):S

```
:::





### :tomato:  ç°åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å­—ç¬¦æ˜¯å¦é‡å¤


```ts
type S1 = CheckRepeatedChars<'abc'>  // false
type S2 = CheckRepeatedChars<'aba'> // true
```

::: tip å¯ä»¥å‚è€ƒæ•°ç»„åˆ¤æ–­é‡å¤ï¼Œå€ŸåŠ©è¾…åŠ©å‡½æ•°åˆ¤æ–­æ˜¯å¦é‡å¤
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// è¾…åŠ©å‡½æ•° åˆ¤æ–­æŒ‡å®šå­—ç¬¦ä¸²æ˜¯å¦é‡å¤
type IsRepeated<T extends string, U extends string, M extends any[] = []> =
  T extends `${infer L}${infer R}` ?
  U extends L ? IsRepeated<R, U, [...M, L]> : IsRepeated<R, U, M>
  : M['length'] extends 1 ? false : true

// ç»“æœ
type CheckRepeatedChars<T extends string, O extends string = T> = 
T extends `${infer L}${infer R}` 
? IsRepeated<O, L> extends true ? true : CheckRepeatedChars<R, O> : false

```

:::



### :tomato: å®ç° å•è¯é¦–å­—æ¯å¤§å†™ 

å®ç°`CapitalWords`ï¼Œå®ƒå°†å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯è½¬æ¢ä¸ºå¤§å†™å­—æ¯ï¼Œå…¶ä½™éƒ¨åˆ†ä¿æŒåŸæ ·ã€‚

```ts
type H1 = CapitalizeWords<"A"> // => 'A'
type H2 = CapitalizeWords<"AB">// => 'Ab'
type H3 = CapitalizeWords<"ABC"> // => 'Abc'
type H4 = CapitalizeWords<" ABC"> // => " Abc"
type H5 = CapitalizeWords<" ABC "> //  => ' Abc '
type H6 = CapitalizeWords<" ABC aDmin"> // => ' Abc Admin '
type H7 = CapitalizeWords<"Hello world hElLO WORlD"> // => Hello World Hello World
```



::: tip åˆ†æ

- æœ¬é¢˜è§£æ³•åŒ[capitalizewords](https://github.com/type-challenges/type-challenges/blob/main/questions/00112-hard-capitalizewords/README.md)
- ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œå°† Head æŒ‡å‘ä¸Šä¸€æ¬¡éå†çš„å­—ç¬¦ä¸²

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Line = "_" | "-" | "__"

type CamelCase<T extends string, Head extends string = "", W extends string = "",> = T extends `${infer L}${infer R}`
  ? L extends Line ? CamelCase<R, L, W> : Head extends Line ? CamelCase<R, L, `${W}${Uppercase<L>}`> : CamelCase<R, L, `${W}${Lowercase<L>}`> : W extends `${infer L}${infer R} ` ? `${Lowercase<L>}${R} ` : W

```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27563)





### :tomato: å®ç° CamelCase 



```ts
type camelCase1 = CamelCase<'hello_world_with_types'> // expected to be 'helloWorldWithTypes'
type camelCase2 = CamelCase<'HELLO_WORLD_WITH_TYPES'> // expected to be same as previous one
```



::: tip åˆ†æ

- éšå«æ¡ä»¶ï¼Œä¸åªæ˜¯å°†ç¬¬ä¸€ä¸ªå•è¯å¤§å†™ï¼Œè¿˜å¿…é¡»å°†åé¢ç›¸è¿çš„å­—æ¯å°å†™ï¼ï¼ï¼

- æœ¬é¢˜éš¾åº¦åœ¨äºå¦‚æœåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²æƒ…å†µä¸‹ç¬¬ä¸€ä¸ªé¦–å­—æ¯å¤§å†™ï¼Œå¦‚ `A` = >`A`,`a`=`A`,`AB` = >`Ab`,`ab`=>`Ab`ï¼Œ`aB`=>`Ab`
- å¦‚æœç›´æ¥åˆ¤æ–­è¯å®¹æ˜“é”™è¯¯ï¼Œè¯¥é¢˜æœ‰ç‚¹åƒé“¾è¡¨éå†ï¼Œå› æ­¤é‡‡ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œä¸ç®¡æœ‰æ²¡æœ‰å†…å®¹ï¼Œå¤´èŠ‚ç‚¹é»˜è®¤ä¸º ""[ç©ºå­—ç¬¦ä¸²]

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ç©ºå­—ç¬¦ä¸²æƒ…å†µ
type Space = "" | " " | "\n" | "\t"

// Head ä¸ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œé»˜è®¤ä¸º ""
// ä¸ä»…è¦åˆ¤æ–­å¤´èŠ‚ç‚¹ä¸ºç©ºï¼è¿˜è¦åˆ¤æ–­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
type CapitalizeWords<S extends string, Head extends string = "", W extends string = ""> =
  S extends `${infer L}${infer R}` ? Head extends Space ? L extends Space ?
  CapitalizeWords<Lowercase<R>, L, `${W}`> :
  CapitalizeWords<Lowercase<R>, L, `${W}${Uppercase<L>}`> : CapitalizeWords<Lowercase<R>, L, `${W}${L}`> : W

```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/HokageYeah)





### :question: å®ç° LengthOfString

è¿™ä¸ªé—®é¢˜ä¸åŒäºä¸Šé¢ [`å®ç°è·å–å­—ç¬¦ä¸²é•¿åº¦`](#å®ç°è·å–å­—ç¬¦ä¸²é•¿åº¦) 

```ts
type T0 = LengthOfString<"foo"> // 3
```



::: tip é—®é¢˜ä¸éš¾ï¼ä½†å®ƒä»¬éƒ½å—åˆ°TypeScriptçš„é€’å½’é™åˆ¶çš„é™åˆ¶ï¼Œè¿™æ˜¯è¿™ä¸ªé—®é¢˜çš„ä¸»è¦çº¦æŸ

:::

![LengthOfString](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/vue-page/image-20230522113503902.png)

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// todo
```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://www.bing.com)





## å‡½æ•°ç³»åˆ—



### å®ç°è·å–å‡½æ•°è¿”å›ç±»å‹

ä¸ä½¿ç”¨ ReturnType å®ç° TypeScript çš„ `ReturnType<T>` æ³›å‹ã€‚
example:

```ts
const fn = (v: boolean) => {
    if (v)
        return 1
    else
        return 2
}

type a = MyReturnType<typeof fn> // åº”æ¨å¯¼å‡º "1 | 2"
```


::: tip

tsä¸­å‡½æ•°è¡¨ç¤ºæ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨å…³é”®è¯`infer`æå–å‡½æ•°è¿”å›ç±»å‹

:::




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyReturnType<T> = T extends (...args: any) => infer R ? R : never
```

:::





### å®ç°å‚æ•°è¿½åŠ 



```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean> 
// expected be (a: number, b: string, x: boolean) => number
```



::: tip å‡½æ•°è¡¨ç°å½¢å¼ä»¥åŠå‚æ•°å’Œè¿”å›ç±»å‹æå–

:::





### å®ç°å‡½æ•°å‚æ•°åè½¬

æœ¬é¢˜å¯ä»¥å‚è€ƒæ•°ç»„åè½¬

```TS
type Flipped = FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>
// (arg0: boolean, arg1: number, arg2: string) => void
```



::: details

```ts
// æä¾›ä¸€ä¸ªåè½¬æ•°ç»„ç±»å‹
type Reverse<T extends any[]> = T extends [...infer F, infer R] ? [R, ...Reverse<F>] : T

// å‚æ•°åè½¬
type FlipArguments<T extends (...args: any[]) => any> =
  T extends (...args: infer Args) => infer R ?
  (...args: Reverse<Args>) => R : never
```

:::



## Object ç³»åˆ—





### å®ç°è¿ä¸¤ä¸ªå¯¹è±¡åˆå¹¶



```ts
type foo = {
  name: string;
  age: string;
}
type coo = {
  age: number;
  sex: string
}

type Result = Merge<foo,coo>; // expected to be {name: string, age: number, sex: string}
```

::: tip  å‚è€ƒä¸Šé¢ç»™å¯¹è±¡æ·»åŠ æ–°å±æ€§æ¡ˆä¾‹ï¼Œæ³¨æ„åé¢å¯¹è±¡åŒåå±æ€§å¿…é¡»è¦è¦†ç›–å‰é¢å¯¹è±¡è¿™ä¸ªè¦æ±‚
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Merge<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in J | K]: key extends J ? U[key] : (key extends K ? T[key] : never)
}
```

:::





### :door:å®ç°å¯é…ç½®å¯é€‰é“¾

```ts
declare const config: Chainable


const result = config
    .option('foo', 123)
    .option('name', 'type-challenges')
    .option('bar', { value: 'Hello World' })
    .get()

// expect the type of result to be:
type TR = typeof result;
interface Result {
    foo: number
    name: string
    bar: {
        value: string
    }
}


```



::: tip

- è€ƒè™‘å±æ€§æ˜¯å¦å­˜åœ¨ç±»å‹ä¸­
- å»ºé€ è€…æ¨¡å¼ï¼ˆoption æ–¹æ³•ç±»ä¼¼äºå»ºé€ è€…æ¨¡å¼ï¼‰
- æ–¹æ³•è¡¨è¾¾å¼
  :::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ç¬¬ä¸€æ­¥å†™å‡ºæœ€ç®€å•å½¢å¼
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K, v: V) => T,
    get: () => T
};

// ç¬¬äºŒéƒ¨è€ƒè™‘ k æ˜¯å¦å­˜åœ¨ä¸ T ä¸­
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T ? never : K, v: V) => T,
    get: () => T
};

// ç¬¬ä¸‰æ­¥ å¦‚æœå°† K V å¯¹åº”å±æ€§æ·»åŠ åˆ° T ä¸­ è¿™é‡Œä½¿ç”¨ Omit<T,K>
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>>,
    get: () => T
};

// ç¬¬å››æ­¥ï¼Œä½¿ç”¨ Record åˆå¹¶å±æ€§
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>&Record<K,V>>,
    get: () => T
};

```


:::











::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ç¬¬ä¸€æ­¥å†™å‡ºå½¢å¼
type AppendArgument<Fn, A> = Fn extends (...args: any[]) => void?(...args: any[]) => void:never

// ç¬¬äºŒæ­¥ä½¿ç”¨inferæå–å‚æ•°å’Œè¿”å›ç±»å‹
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer T ? (...args: [...P, A]) => T : never
```

:::



### å®ç°ä¸ºä¸€ä¸ªæ¥å£æ·»åŠ æ–°ç±»å‹

å®ç°ä¸€ä¸ªä¸ºæ¥å£æ·»åŠ ä¸€ä¸ªæ–°å­—æ®µçš„ç±»å‹ã€‚è¯¥ç±»å‹æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œè¿”å›å¸¦æœ‰æ–°å­—æ®µçš„æ¥å£ç±»å‹ã€‚

```ts
type Test = { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

::: tip æ„é€ ä¸€ä¸ªKï¼ŒVç»™å¯¹è±¡ï¼Œå‚è€ƒRecordå®ç°
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type AppendToObject<T, U extends keyof any, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```

:::





### :tea: å®ç° Diff

è·å–ä¸¤ä¸ªæ¥å£ç±»å‹ä¸­çš„å·®å€¼å±æ€§ã€‚

```ts
type Foo = {
  a: string;
  b: number;
}
type Bar = {
  a: string;
  c: boolean
}

type Result1 = Diff<Foo,Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar,Foo> // { b: number, c: boolean }


```


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
//
//  è§£æ³•ä¸€ã€æˆ‘è‡ªå·±è§£æ³• å¤ªå¤æ‚äº†ğŸ˜´
// [key in K | J as key extends K & J ? never : key]
// key å±äºå¹¶é›† å•ä¸å±äº äº¤é›†
type Diff<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in K | J as key extends K & J ? never : key]:
  key extends K ? key extends J ? never : T[key]
  : (key extends J ? (key extends K ? never : U[key]) : never)
}

// è§£æ³•äºŒ
// [key in keyof (U & T) as key extends keyof (T | U) ? never : key]
// key å±äº T Uçš„å¹¶é›† å•ä¸å±äºäº¤é›†
type Diff<T, U> = {
  [key in keyof (U & T) as key extends keyof (T | U) ? never : key]: (U & T)[key]
}

// è§£æ³•ä¸‰ï¼Œä½¿ç”¨ Omit
// æ³¨æ„äº†è§£ Omit çš„ç”¨æ³•ï¼Œ
type Diff<T, U> = Omit<T & U, keyof (U | T)>



```

:::


**æ‹“å±•**

```ts
// å¦‚æœæ˜¯å¯¹è±¡ç±»å‹ï¼Œ 
//    | è¡¨ç¤º äº¤é›†ï¼Œ& è¡¨ç¤ºå¹¶é›†
// äº¤é›†
type A = keyof (Foo | Bar) // type A = "a" 
// å¹¶é›†
type B = keyof (Foo & Bar) // type B = "a" | "b" | "c"


// å¯¹äºè”åˆç±»å‹ 
//  | è¡¨ç¤º å¹¶é›†ï¼Œ & è¡¨ç¤º äº¤é›†
// å¹¶é›†
type C = (keyof Foo) | (keyof Bar) // type C = "a" | "b" | "c"
// äº¤é›†
type D = (keyof Foo) & (keyof Bar) // type D = "a" 
```







### :rocket: å®ç°å±æ€§æ›¿æ¢



```ts
type NodeA = {
  type: 'A'
  name: string
  flag: number
}

type NodeB = {
  type: 'B'
  id: number
  flag: number
}

type NodeC = {
  type: 'C'
  name: string
  flag: number
}


type Nodes = NodeA | NodeB | NodeC

// {type: 'A', name: number, flag: string} 
// |{type: 'B', id: number, flag: string} 
// | {type: 'C', name: number, flag: string} 
type ReplacedNodes = ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>

// 
// {type: 'A', name: never, flag: number} 
// | NodeB 
// | {type: 'C', name: never, flag: number} // would replace name to never
type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }> 
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// æˆ‘çš„è§£æ³•
type ReplaceKeys<T, U, S> = T extends T ?
  {
    [key in keyof T]: key extends U ? (
      key extends keyof S ? S[key] : never
    ) : key extends keyof S ? S[key] : T[key]
  }
  : never


// å‚è€ƒç­”æ¡ˆ
type ReplaceKeys<U, T, Y> = U extends U
  ? {
      [I in keyof U]: I extends T ? (I extends keyof Y ? Y[I] : never) : U[I];
    }
  : never;

// å‚è€ƒç­”æ¡ˆ
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? (K extends keyof Y ? Y[K] : never) : U[K]

```

:::





### :checkered_flag: å®ç°ç§»é™¤ç´¢å¼•ç­¾å

[ä»€ä¹ˆæ˜¯ç´¢å¼•ç­¾åï¼Ÿ](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)

> Only some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.

> ç´¢å¼•ç­¾åå±æ€§åªå…è®¸ä½¿ç”¨æŸäº›ç±»å‹ï¼šå­—ç¬¦ä¸²ã€æ•°å­—ã€ç¬¦å·ã€æ¨¡æ¿å­—ç¬¦ä¸²æ¨¡å¼ä»¥åŠä»…ç”±è¿™äº›ç±»å‹ç»„æˆçš„å¹¶é›†ç±»å‹ã€‚

```ts
type Foo = {
  [key: string]: any;
  foo(): void;
}

type A = RemoveIndexSignature<Foo>  // expected { foo(): void }

```

::: tip **ts**è‡ªå¸¦ç´¢å¼•ç­¾åç±»å‹çš„è”åˆç±»å‹**PropertyKey**
:::


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type S = string | symbol | number
type RemoveIndexSignature<T, P = S> = {
  [key in keyof T as P extends key ? never : key extends P? key : never]: T[key]
}

```

:::







### :thinking: å®ç° Entries







ä»Tä¸­ï¼Œé€‰æ‹©ä¸€ç»„ç±»å‹ä¸å¯åˆ†é…ç»™Uçš„å±æ€§ã€‚

```ts
interface Model {
  name: string;
  age: number;
  locations: string[] | null;
}
type modelEntries = ObjectEntries<Model> // ['name', string] | ['age', number] | ['locations', string[] | null];
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type ObjectEntries<T, U extends keyof T = keyof T> = U extends unknown 
  ? [U, T[U] extends (infer F | undefined) 
    ? F
    : T[U]
  ] 
: never
```

:::





### :thinking: å®ç° å…ƒç»„é€’å½’è½¬æ¢æˆå¯¹è±¡







ä»Tä¸­ï¼Œé€‰æ‹©ä¸€ç»„ç±»å‹ä¸å¯åˆ†é…ç»™Uçš„å±æ€§ã€‚

```ts
// å…ƒç»„è½¬æ¢æˆå¯¹è±¡
type a = TupleToNestedObject<['a'], string> // {a: string}
type b = TupleToNestedObject<['a', 'b'], number> // {a: {b: number}}
type c = TupleToNestedObject<[], boolean> // boolean. if the tuple is empty, just return the U type
type d = TupleToNestedObject<['a', 'b', 'c'], number> // {a: {b: {c:number}}}
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type TupleToNestedObject<T extends any[], U> =
  T extends [infer L, ...infer R] ? {
    [key in L & string]: TupleToNestedObject<R, U>
  } : U

```

:::





### :thinking: å®ç° å°†å…ƒç»„è½¬æ¢æˆæšä¸¾



```ts
type Arr = ["macOS", "Windows", "Linux"]

type A1 = Enum<Arr, false>
// expect
// type A1 = {
//   readonly macOS: "macOS";
//   readonly Windows: "Windows";
//   readonly Linux: "Linux";
// }
type A2 = Enum<Arr, true>
// expect
// type A2 = {
//   readonly macOS: 0;
//   readonly Windows: 1;
//   readonly Linux: 2;
// }

```



::: tip æ•°ç»„è½¬æ¢æˆå¯¹è±¡ éå†æ–¹å¼

:::





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type UseIndex<T extends readonly unknown[], k extends string, U extends unknown[] = []> = T extends [infer L, ...infer R] ? [L] extends [k] ? U['length']
  : UseIndex<R, k, [...U, unknown]> : -1

type Enum<T extends readonly any[], B extends boolean = false> = {
  +readonly [K in T[number]]: B extends true ? UseIndex<T, K> : K
}

```

:::





[æœ¬é¢˜è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27568)






## å…¶ä»–














### å®ç° Omit

ä¸ä½¿ç”¨ Omit å®ç° TypeScript çš„ Omit<T, K> æ³›å‹ã€‚

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
    completed: false,
}
```


::: tip

- keyof
- in
- extends
- never

:::




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyOmit<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P]
}
```

:::







### å®ç°å…ƒç»„è½¬æ¢æˆè”åˆç±»å‹

```ts
type Arr = ['java', 'javascript', 'typescript', "node", "springboot"]

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'


```



::: tip

- é€’å½’
- infer

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// è§£æ³•ä¸€ï¼Œè‡ªå·±åšçš„
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer L] ? F | TupleToUnion<L> : never

// è§£æ³•äºŒ ï¼Œè¯´å®è¯ï¼Œæ ¹æœ¬çœ‹ä¸æ‡‚ï¼
// åŸç­”æ¡ˆé“¾æ¥ https://github.com/type-challenges/type-challenges/issues/284
type TupleToUnion<T extends any[]> = T[number]
```

:::





### å®ç° Absolute

å®ç°ä¸€ä¸ªæ¥æ”¶string,numberæˆ–bigIntç±»å‹å‚æ•°çš„Absoluteç±»å‹,è¿”å›ä¸€ä¸ªæ­£æ•°å­—ç¬¦ä¸²

```ts
type Test = -100;
type Result = Absolute<Test>; // expected to be "100"
```

::: tip ç”¨å­—ç¬¦ä¸²å’Œinferå¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type Absolute<T extends string | number | bigint> = `${T}` extends `-${infer R}` ? R : `${T}`
```
:::







### :question: å®ç° Anyof

åœ¨ç±»å‹ç³»ç»Ÿä¸­å®ç°ç±»ä¼¼äº Python ä¸­ any å‡½æ•°ã€‚ç±»å‹æ¥æ”¶ä¸€ä¸ªæ•°ç»„ï¼Œå¦‚æœæ•°ç»„ä¸­ä»»ä¸€ä¸ªå…ƒç´ ä¸ºçœŸï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å› falseã€‚
```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.

```

::: tip å¯¹è±¡ç±»å‹ ä½¿ç”¨ `keyof` éå† å±æ€§ï¼Œæ•°ç»„ä½¿ç”¨ `[number]` éå†å±æ€§
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type FALSE = 0 | '' | false | [] | { [key: string]: never }


type AnyOf<T extends any[]> = T[number] extends FALSE
  ? false : true;
```
:::


**æ‹“å±•**

```ts
type a1 = {} extends { name: 'a' } ? true : false // false
type b1 = { name: 'a' } extends {} ? true : false // true
type c1 = { [key: string]: never } extends {} ? true : false // true
type d1 = {} extends { [key: string]: never } ? true : false // true
```


### :x: ~~å®ç° IsNever~~

```ts
type A = IsNever<never>  // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsNever<T> = [T] extends [never] ? true : false
// ä¸ºä»€ä¹ˆéœ€è¦æ‹¬å·ï¼Ÿ       ç›´æ¥ T extends never ? ä¸è¡Œå—

// æµ‹è¯•
type Is_Never<T> = T extends never ? true : false
type A = Is_Never<never>; // => æ¨ç®—ç»“æœä¸º never è€Œä¸æ˜¯ true æ˜¾ç„¶ä¸ç¬¦åˆé¢˜æ„
// å…·ä½“åŸå› è¯·æŸ¥çœ‹ä¸‹é¢é“¾æ¥
```
:::

**çŸ¥è¯†ç‚¹**

æƒ³è¦æ¶ˆé™¤åˆ†å‘ç‰¹æ€§ï¼Œç”¨ `[]` åŒ…è£¹ä¸‹å°±è¡Œã€‚ [TSåˆ†å‘ç‰¹æ€§](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types) 







### :thinking: å®ç° isUnion


```ts
type case1 = IsUnion<string>  // false
type case2 = IsUnion<string|number>  // true
type case3 = IsUnion<[string|number]>  // false
```


::: warning  é‡ç‚¹ï¼

A extends A å¯¼è‡´Aè¢«åˆ†å‘ï¼Œæ‰€ä»¥åœ¨[B] extends [A] è¿™é‡Œï¼ŒB æ˜¯è”åˆç±»å‹ï¼Œè€ŒA æ˜¯åˆ†å‘ç±»å‹ï¼ŒäºŒè€…å¦‚æœä¸ç­‰ï¼Œé‚£ä¹ˆè¡¨ç¤ºAå°±æ˜¯è”åˆç±»å‹,å…·ä½“çœ‹

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsUnion<A, B = A> = A extends A ? ([B] extends [A] ? false : true) : false;
```
:::







### :thinking: å®ç° MinusOne

ç»™å®šä¸€ä¸ªæ­£æ•´æ•°ä½œä¸ºç±»å‹çš„å‚æ•°ï¼Œè¦æ±‚è¿”å›çš„ç±»å‹æ˜¯è¯¥æ•°å­—å‡ 1ã€‚

```ts
type Zero = MinusOne<1> // 0
type FiftyFour = MinusOne<55> // 54
```



::: tip tsä¸­æ˜¯æ— æ³•ç›´æ¥å‡ä¸€çš„ï¼Œä½†æ˜¯æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œå¯ä»¥è”æƒ³æ•°ç»„ï¼Œæ•°ç»„çš„é•¿åº¦å’Œæœ€å¤§ä¸‹æ ‡å°±æ˜¯å·®ä¸€ï¼

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MinusOne<T, P extends any[] = []>
  = P['length'] extends T ? P extends [...infer F, any] ? F['length'] : []['length'] : MinusOne<T, [...P, 0]>

```

:::



### å®ç° PickByType

æŒ‘é€‰å‡ºç±»å‹

```ts
type OnlyBoolean = PickByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { isReadonly: boolean; isEnable: boolean; }
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// è§£æ³•ä¸€
type PickByType<T extends object = {}, U = any> = {
  [K in keyof T as T extends K ? never : T[K] extends U ? K : never]: T[K]
}

// è§£æ³•äºŒ æ˜¯è¦ pick æ³¨æ„ {}[keyof T] çš„å«ä¹‰
type PickByType<T, U> = { [K in keyof T]: T[K] extends U ? K : never }[keyof T]


// è§£æ³•ä¸‰ å’Œ è§£æ³•ä¸€ç±»ä¼¼
type PickByType<T extends Object, U> = {
  [Key in keyof T as T[Key] extends U ? Key : never]: T[Key]
}
```

:::





### :tomato: å®ç° PartialByKeys



å®ç°ä¸€ä¸ªé€šç”¨çš„`PartialByKeys<T, K>`ï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªç±»å‹å‚æ•°`T`å’Œ`K`ã€‚

`K`æŒ‡å®šåº”è®¾ç½®ä¸ºå¯é€‰çš„`T`çš„å±æ€§é›†ã€‚å½“æ²¡æœ‰æä¾›`K`æ—¶ï¼Œå®ƒå°±å’Œæ™®é€šçš„`Partial<T>`ä¸€æ ·ä½¿æ‰€æœ‰å±æ€§éƒ½æ˜¯å¯é€‰çš„ã€‚

```ts
interface User {
  name: string
  age: number
  address: string
}

type UserPartialName = PartialByKeys<User, 'name'> // { name?:string; age:number; address:string }
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IO<T extends object = {}> = {
    [k in keyof T]: T[k]
}


type PartialByKeys<T extends object = {}, K = any> =
IO<
    {
        [P in keyof T as P extends K ? P : never]?: T[P]
    }
    &
    {
        [P in keyof T as P extends K ? never : P]: T[P]
    }
>


// è§£æ³•äºŒ
type PartialByKeys<T extends object = {}, K = any> =
  IO<
    {
      [P in Extract<keyof T, K>]?: T[P]
    }
    &
    {
      [P in Exclude<keyof T, K>]: T[P]
    }
  >


```

:::



::: tip

- Extract æœŸæœ›ç±»å‹
- Exclude æ’é™¤ç±»å‹
- è”åˆç±»å‹ä¸­`&` è¡¨ç¤ºäº¤é›†, `|` è¡¨ç¤ºå¹¶é›†ï¼›å¯¹è±¡ç±»å‹ä¸­`&` è¡¨ç¤ºå¹¶é›†, `|` è¡¨ç¤ºäº¤é›†

:::









### å®ç° OmitByType



ä»Tä¸­ï¼Œé€‰æ‹©ä¸€ç»„ç±»å‹ä¸å¯åˆ†é…ç»™Uçš„å±æ€§ã€‚

```ts
type OmitBoolean = OmitByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { name: string; count: number }
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}
```

:::





### :page_facing_up: Bem æ¶æ„

å—ã€å…ƒç´ ã€ä¿®é¥°ç¬¦æ–¹æ³•è®ºï¼ˆBEMï¼‰æ˜¯CSSä¸­å¸¸ç”¨çš„ç±»å‘½åçº¦å®šã€‚ä¾‹å¦‚ï¼Œå—ç»„ä»¶å°†è¡¨ç¤ºä¸ºbtnï¼Œä¾èµ–äºå—çš„å…ƒç´ å°†è¡¨ç¤ºä¸ºbtn_priceï¼Œæ”¹å˜å—æ ·å¼çš„ä¿®é¥°ç¬¦å°†è¡¨ç¤ºä¸ºbtn-bigæˆ–btn_price-warningã€‚å®ç°BEM<Bï¼ŒEï¼ŒM>ï¼Œæ ¹æ®è¿™ä¸‰ä¸ªå‚æ•°ç”Ÿæˆå­—ç¬¦ä¸²å¹¶é›†ã€‚å…¶ä¸­Bæ˜¯å­—ç¬¦ä¸²æ–‡å­—ï¼ŒEå’ŒMæ˜¯å­—ç¬¦ä¸²æ•°ç»„ï¼ˆå¯ä»¥ä¸ºç©ºï¼‰ã€‚

```ts
type A = BEM<'el', ['button', 'button'], ['primary', 'success']>
// "el__button--primary" | "el__button--success"
```





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsNever<T> = [T] extends [never] ? true : false
type IsUnion<T> = IsNever<T> extends true ? "" : T
type BEM<B extends string, E extends string[], M extends string[]> = `${B}${IsUnion<`__${E[number]}`>}${IsUnion<`--${M[number]}`>}`
```

:::





### :tomato:  æŒ‡å®šè¿”å›çš„è”åˆç±»å‹





```ts
type result = NumberRange<2, 9> //  2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
```





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// æ ¹æ®æ•°å­—ç”Ÿæˆæ•°ç»„
type AppendArray<R extends number, T extends any[] = []> = T['length'] extends R ? T : AppendArray<R, [...T, T['length']]>

// æ•°å€¼åŠ ä¸€
type AddLength<T extends any[]> = [...T, T['length']]

// å»æ‰æŒ‡å®šå‰é¢ä¸ªæ•°
type Shfit<T extends any[], N extends number, U extends any[] = []> =
 U['length'] extends N ? T : T extends [any, ...infer R] ? Shfit<R, N, [...U, 0]> : T

// æ•°ç»„è½¬æ¢è”åˆç±»å‹
type ArrayToUnion<T extends any[]> = T[number]

// result
type NumberRange<T extends number, R extends number> = ArrayToUnion<Shfit<AddLength<AppendArray<R>>, T>>
```

:::









~~// æœªå®Œå¾…ç»­â€¦â€¦~~





# ä¸‰ ã€å›°éš¾



## å…¶ä»–

### :tomato:  å®ç°æŸ¯é‡ŒåŒ–

```ts
const add = (a: number, b: number) => a + b
const three = add(1, 2)

const curriedAdd = Currying(add)
const five = curriedAdd(2)(3)
```



::: tip æŸ¯ç†åæœ¬è´¨æ˜¯çœ‹å‡½æ•°æœ‰å‡ ä¸ªå‚æ•°ï¼Œå¤šå°‘ä¸ªå‚æ•°è¿”å›å¤šå°‘ä¸ªå‡½æ•°ï¼Œä½¿ç”¨é€’å½’

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
declare function Currying<F>(fn: F): Curried<F>

// åŸå‡½æ•°è¿”å›
type Curried<F> = F extends (...args: infer Args) => infer R ?
  (...arg: Args) => R 
  : never


 // åˆ¤æ–­å‡½æ•°å‚æ•°ä¸ªæ•°ï¼Œä½¿ç”¨é€’å½’ ã€ç­”æ¡ˆã€‘
type Curried<F> = F extends (...args: infer Args) => infer R ?
  Args extends [infer First, ...infer Other] ? (arg: First) => Curried<(...args: Other) => R> : R
  : never


```

:::











### :tomato:  å®ç° GetRequired

å®ç°é«˜çº§utilç±»å‹`GetRequired<T>`ï¼Œè¯¥ç±»å‹ä¿ç•™æ‰€æœ‰å¿…å¡«å­—æ®µ

```ts
type I = GetRequired<{ foo: number, bar?: string }> // expected to be { foo: number }
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// è§£æ³•ä¸€
// ä½¿å¾—æ‰€æœ‰keyå˜æˆå¿…é¡»é€‰ç±»å‹
type MyRequried<T> = {
  [k in keyof T]-?: T[k]
}

type GetRequired<T> = {
  [key in keyof T as T[key] extends MyRequried<T>[key] ? key : never]: T[key]
}



// è§£æ³•äºŒ


```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27555)





### :tomato: å®ç° GetRequiredkeys



```ts
type Result = RequiredKeys<{ foo: number; bar?: string }>;
// expected to be â€œfooâ€
```



::: tip  å’Œä¸Šé¢è§£æ³•ç±»ä¼¼ï¼Œå¯¹è±¡ç±»å‹è½¬æ¢æˆè”åˆç±»å‹

:::





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyRequried<T> = {
  [key in keyof T]-?: T[key]
}

type GetRequired<T> = {
  [key in keyof T as T[key] extends MyRequried<T>[key] ? key : never]: key
}
type RequiredKeys<T> = GetRequired<T>[keyof GetRequired<T>]

```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27556)





**æ‹“å±•**

- Arrayç±»å‹è½¬æ¢æˆè”åˆç±»å‹





### :tomato: å®ç° GetOptional

ä¿ç•™å¯é€‰ç±»å‹çš„keyï¼Œè½¬æ¢æˆè”åˆç±»å‹

```ts
type I = GetOptional<{ foo: number, bar?: string }> // expected to be { bar?: string }
```



::: tip  å’Œä¸Šé¢è§£æ³•ç±»ä¼¼ï¼Œåªä¸è¿‡æ”¹å˜äº†ä¸€ä¸‹åˆ¤æ–­ä¾æ®

:::





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyRequired<T> = {
  [key in keyof T]-?: T[key]
}


type GetOptional<T> = {
  [key in keyof T as T[key] extends MyRequired<T>[key] ? never : key]: T[key]
}


```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27557)





### :tomato: å®ç° GetOptionalKeys

ä¿ç•™å¯é€‰ç±»å‹çš„keyï¼Œè½¬æ¢æˆè”åˆç±»å‹

```ts
type I = GetOptional<{ foo: number, bar?: string }> // expected to be "bar"
```





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts


type MyRequired<T> = {
  [key in keyof T]-?: T[key]
}


type GetOptional<T> = {
  [key in keyof T as T[key] extends MyRequired<T>[key] ? never : key]: key
}

// å°†å¾—åˆ°çš„å¯é€‰ç±»å‹è½¬æ¢æˆå¿…é¡»ç±»å‹ï¼Œå»é™¤ undefined 
type OptionalKeys<T> = MyRequired<GetOptional<T>>[keyof MyRequired<GetOptional<T>>]
```



:::

[ç‚¹å‡»æŸ¥çœ‹æœ¬åœ°è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27560)









### :x: å®ç° PromiseAll



// ....







### :x: å®ç° JSONP

// ...









### :tomato: å®ç° SimpleVue



å®ç°ç±»ä¼¼Vueçš„ç±»å‹æ”¯æŒçš„ç®€åŒ–ç‰ˆæœ¬ã€‚

é€šè¿‡æä¾›ä¸€ä¸ªå‡½æ•°`SimpleVue`ï¼ˆç±»ä¼¼äº`Vue.extend`æˆ–`defineComponent`ï¼‰ï¼Œå®ƒåº”è¯¥æ­£ç¡®åœ°æ¨æ–­å‡º computed å’Œ methods å†…éƒ¨çš„`this`ç±»å‹ã€‚

åœ¨æ­¤æŒ‘æˆ˜ä¸­ï¼Œæˆ‘ä»¬å‡è®¾`SimpleVue`æ¥å—åªå¸¦æœ‰`data`ï¼Œ`computed`å’Œ`methods`å­—æ®µçš„Objectä½œä¸ºå…¶å”¯ä¸€çš„å‚æ•°ï¼Œ

- `data`æ˜¯ä¸€ä¸ªç®€å•çš„å‡½æ•°ï¼Œå®ƒè¿”å›ä¸€ä¸ªæä¾›ä¸Šä¸‹æ–‡`this`çš„å¯¹è±¡ï¼Œä½†æ˜¯ä½ æ— æ³•åœ¨`data`ä¸­è·å–å…¶ä»–çš„è®¡ç®—å±æ€§æˆ–æ–¹æ³•ã€‚
- `computed`æ˜¯å°†`this`ä½œä¸ºä¸Šä¸‹æ–‡çš„å‡½æ•°çš„å¯¹è±¡ï¼Œè¿›è¡Œä¸€äº›è®¡ç®—å¹¶è¿”å›ç»“æœã€‚åœ¨ä¸Šä¸‹æ–‡ä¸­åº”æš´éœ²è®¡ç®—å‡ºçš„å€¼è€Œä¸æ˜¯å‡½æ•°ã€‚
- `methods`æ˜¯å‡½æ•°çš„å¯¹è±¡ï¼Œå…¶ä¸Šä¸‹æ–‡ä¹Ÿä¸º`this`ã€‚å‡½æ•°ä¸­å¯ä»¥è®¿é—®`data`ï¼Œ`computed`ä»¥åŠå…¶ä»–`methods`ä¸­çš„æš´éœ²çš„å­—æ®µã€‚ `computed`ä¸`methods`çš„ä¸åŒä¹‹å¤„åœ¨äº`methods`åœ¨ä¸Šä¸‹æ–‡ä¸­æŒ‰åŸæ ·æš´éœ²ä¸ºå‡½æ•°ã€‚

`SimpleVue`çš„è¿”å›å€¼ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„ã€‚



```ts
const instance = SimpleVue({
  data() {
    return {
      firstname: 'Type',
      lastname: 'Challenges',
      amount: 10,
    }
  },
  computed: {
    fullname() {
      return this.firstname + ' ' + this.lastname
    }
  },
  methods: {
    hi() {
      alert(this.fullname.toLowerCase())
    }
  }
})
```





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type GetComputed<C> = C extends Record<string, (...args: any[]) => any> 
  ? { [S in keyof C]: ReturnType<C[S]> } 
  : never

declare function SimpleVue<D, C, M>(
  options: {
    data: () => D,
    computed: C,
    methods: M,
  } & ThisType<D & M & GetComputed<C>>
): any
```

:::





### :tea: å®ç°å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å­—



::: details

```ts
type ToNumber<S extends string> = S extends `${infer N extends number}` ? N : never;
```

:::





### :thinking: å®ç°ä¸¤æ•°ä¹‹å’Œ

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target, å¦‚æœ nums æ•°ç»„ä¸­å­˜åœ¨ä¸¤ä¸ªå…ƒç´ çš„å’Œç­‰äº target è¿”å› true, å¦åˆ™è¿”å› false



::: tip ç†æ¸…æ€è·¯ï¼Œæ’åºï¼Œå·¦å³æŒ‡é’ˆ





::: details

```ts
// æ–¹æ³•ä¸€ä½¿ç”¨å‡½æ•°å®ç° 
function TowSum(nums: number[], target: number): boolean {
  if (nums['length'] < 2) {
    return false
  }
  nums.sort((a, b) => a - b > 0 ? 1 : -1)
  let left = 0, right = nums['length'] - 1
  let sum: number
  while (left < right) {
    sum = nums[left] + nums[right]
    if (sum === target) {
      return true
    } else if (sum > target) {
      right--;
    } else if (sum < target) {
      left++;
    }
  }
  return false
}


// æ–¹æ³•äºŒä½¿ç”¨ç±»å‹å®ç°

```



:::





[æˆ‘çš„è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27374)





### :yum: å®ç°æ—¥æœŸéªŒè¯

è¦æ±‚å®ç°ä¸€ä¸ªç±»å‹éªŒè¯æœˆä»½å’Œæ—¥æœŸ

```ts
ValidDate<'0102'> // true
ValidDate<'0131'> // true
ValidDate<'1231'> // true
ValidDate<'0229'> // false
ValidDate<'0100'> // false
ValidDate<'0132'> // false
ValidDate<'1301'> // false
```

::: tip æœ¬é¢˜å¯ä»¥é‡‡ç”¨æšä¸¾å®ç°,çŸ¥é“å“ªäº›æœˆä»½æ˜¯æœˆå¤§ï¼Œå“ªäº›æ˜¯æœˆå°ï¼Œä»¥åŠäºŒæœˆä»½æ˜¯ä¸€ä¸ªç‰¹æ®Šæœˆä»½ï¼

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// æ•°å­—çš„èŒƒå›´
type Num = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

type D = 0 | 1 | 2
// æœˆå°
type MinMM = `0${4 | 6 | 7}` | `11`
// æœˆå¤§
type MaxMM = Exclude<`0${Num}` | `1${D}`, MinMM | `02`>

type Day = `${D}${Num}` | `3${Exclude<D, 2>}`

type ValidDate<T extends string> = T extends `${MaxMM}${Day}` | `${MinMM}${Exclude<Day, `31`>}` | `02${Exclude<Day, `29` | `30` | `31`>}` ? true : false


```



:::



[æœ¬é¢˜æˆ‘çš„è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27378)





### :cake: å®ç° Get

å®ç°ä¸€ä¸ªGetç±»å‹ï¼Œè·å–å¯¹è±¡å±æ€§

```ts
type Data = {
  foo: {
    bar: {
      value: 'foobar',
      count: 6,
    },
    included: true,
  },
  hello: 'world'
}
  
type A = Get<Data, 'hello'> // 'world'
type B = Get<Data, 'foo.bar.count'> // 6
type C = Get<Data, 'foo.bar'> // { value: 'foobar', count: 6 }
```

::: tip åˆ¤æ–­ å±æ€§ä¸­æ˜¯å¦å«æœ‰`.`æ˜¯åˆ‡å…¥ç‚¹

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Get<T, K extends string> = K extends `${infer L}.${infer R}` ? L extends keyof T ? Get<T[L], R> : never : K extends keyof T ? T[K] : never
```



:::



[æœ¬é¢˜æˆ‘çš„è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27567)





### :tomato: å®ç° MaxNum



```ts

// è®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼ä¸º0
// å½“ C['length'] === A | B æ—¶é€€å‡ºé€’å½’
// åˆ¤æ–­ C['length'] === A or  C['length'] === B å…ˆ === çš„ä¸ºè¾ƒå°å€¼
// ä¸è¿‡è¿™ç§æ–¹å¼å½“ A B å€¼ä¸º è´Ÿæ•°æ—¶ è¯¥æ–¹æ¡ˆé”™è¯¯ï¼
// å› æ­¤åˆ†ä¸ºå››ç§æƒ…å†µ
// 1 A>= 0 B>=0     ===========> æ¯”è¾ƒ length ,è°çš„ length å¤§ è¿”å›è°
// 2 A>0 B<0        ===========> ç›´æ¥è¿”å› A
// 3 A<0 B>0        ===========> ç›´æ¥è¿”å› B
// 4 A<0 B<0        ========== > è°çš„lengthå°ï¼Œå€¼è¶Šå¤§
// isAllNegative è¡¨ç¤ºä¸¤ä¸ªæ•°æ˜¯å¦ä¸ºè´Ÿæ•°
// A B è¡¨ç¤ºç»å¯¹å€¼
// A1 è¡¨ç¤º A å¯¹åº” å¦‚æœA æ˜¯æ­£æ•°ï¼ŒL å’Œä¹Ÿæ˜¯æ­£æ•° å¦‚æœ A = 1 ï¼ŒL = 1 =>1; A = 1ï¼ŒA1 = -1 => -1
// B1 åŒ A1ä¸ A å¯¹åº”å…³ç³»
type Compare<A extends number, B extends number, isAllNegative extends boolean = false, A1 extends number = A, B1 extends number = B, C extends any[] = []> =
  C['length'] extends A | B ?
  C['length'] extends A ? isAllNegative extends true ? A1 : B1 : isAllNegative extends true ? B1 : A1
  : Compare<A, B, isAllNegative, A1, B1, [...C, unknown]>


// è¾…åŠ©ç±»å‹
// åˆ¤æ–­æ˜¯å¦æ˜¯è´Ÿæ•°
type IsNegative<T extends number> = `${T}` extends `-${infer A extends number}` ? true : false

// è·å–ç»å¯¹å€¼
type GetNegative<T extends number> = `${T}` extends `-${infer A extends number}` ? A : T


// ä¸¤ä¸ªè´Ÿæ•°æ•°å­—è¶Šå°å€¼è¶Šå¤§ï¼
// å¦‚æœæ˜¯ä¸€ä¸ªæ­£æ•°å’Œä¸€ä¸ªè´Ÿæ•° å°±æ²¡å¿…è¦å¯¹æ¯”äº†ç›´æ¥è¿”å›æ­£æ•°
type Max<A extends number, B extends number> =
  IsNegative<A> extends true
  ? IsNegative<B> extends true
  // A < 0 , B < 0
  ? Compare<GetNegative<A>, GetNegative<B>, true, A, B> : B
  : IsNegative<B> extends true ? A : Compare<A, B>




type Maximum<T extends number[], M extends number = T[0], First extends boolean = true> =
  T['length'] extends 0 ? (
    First extends true ? never : M
  ) :
  T extends [infer A extends number, ...infer B extends number[]] ?
  Maximum<B, Max<A, M>, false> : M




// test
type A1 = Max<10, 2> // 10
type A2 = Max<2, 10> // 10
type B1 = Max<0, 1> // 1
type B2 = Max<0, -1> // 0
type C1 = Max<-1, 1> // 1
type C2 = Max<1, -1> // 1
type D1 = Max<-2, -1> // -1
type D2 = Max<-1, -2> // -1
type E1 = Max<-100, -200> // -100
type E2 = Max<-200, -100> // -100

// test
type arr0 = Maximum<[]> // never
type arr1 = Maximum<[-1, 20, -200, -150]> // 20
type arr2 = Maximum<[-1, -20, -200, -150]> // -1
type arr3 = Maximum<[1, 20, 200, -150]> // 200
type arr4 = Maximum<[0, -1]> // 0
type arr5 = Maximum<[-1, 1]> // 1

```



**æœ¬é¢˜æ˜¯æˆ‘å¤šè€ƒè™‘äº†ï¼Œå®˜æ–¹æ²¡è¦æ±‚è´Ÿæ•°æƒ…å†µ**

> å…³äºæœ¬é¢˜ä¼˜åŒ–æ–¹æ¡ˆæ–¹æ¡ˆ è½¬æ¢æˆå­—ç¬¦ä¸²æ¯”è¾ƒ



ä¸è¿‡æˆ‘å¯ä»¥æ‹“å±•æˆè¦æ±‚è´Ÿæ•°æƒ…å†µ

**ä¼˜åŒ–åç»“æœ**





```ts

// è¾…åŠ©ç±»å‹
type NumToString<T extends number> = `${T}`
// è·å–å­—ç¬¦ä¸²é•¿åº¦
type GetStringLen<T extends string, U extends any[] = []> = T extends `${infer L}${infer R}` ? GetStringLen<R, [...U, L]> : U['length']
// è¿”å›è¾ƒå°æ•°å­—
type GetMinNumber<A extends number, B extends number, L extends any[] = []> = L['length'] extends A | B ? L['length'] extends A ? A : B : GetMinNumber<A, B, [...L, -1]>
// number is equal
type NumIsEqual<A extends number, B extends number> = A extends B ? true : false
// strlen is equal
type StrLenIsEqual<A extends string, B extends string> = GetStringLen<A> extends GetStringLen<B> ? true : false
// è¿”å›è¾ƒå¤§å€¼ A B å±äº 0-9 A1 B1 ä¸ºåŸå§‹å€¼
type GetMaxNumber<A extends number, B extends number, A1 extends number = A, B1 extends number = B, isAllNegative extends boolean = false,>
  = A extends GetMinNumber<A, B> ? isAllNegative extends true ? A1 : B1 : isAllNegative extends true ? B1 : A1

// åˆ¤æ–­æ˜¯å¦æ˜¯è´Ÿæ•°
type IsNegative<T extends number> = `${T}` extends `-${infer A extends number}` ? true : false

// è·å–ç»å¯¹å€¼
type GetNegative<T extends number> = `${T}` extends `-${infer A extends number}` ? A : T



type Compare<
  A extends number,
  B extends number,
  isAllNegative extends boolean = false,
  A1 extends number = A,
  B1 extends number = B,
  S1 extends string = NumToString<A>,
  S2 extends string = NumToString<B>
> =
  StrLenIsEqual<S1, S2> extends true ?
  (
    S1 extends `${infer L1 extends number}${infer R1}` 
    ? S2 extends `${infer L2 extends number}${infer R2}`
    // æ¯”è¾ƒå•ä¸ªå­—ç¬¦ä¸²å¯¹åº”æ•°å­—æƒ…å†µ
    ? NumIsEqual<L1, L2> extends true ?
    // ç›¸ç­‰é€’å½’ä¸‹ä¸€æ¬¡
    Compare<A, B, isAllNegative, A1, B1, R1, R2> :
    // ä¸ç›¸ç­‰è¯æ¯”è¾ƒæ•°å­—å¤§å°
    GetMaxNumber<L1, L2, A1, B1, isAllNegative>
    // å¯¹æ¯”åˆ°æ­¤å¤„è¯´æ˜ A1 === B1 æ‰€ä»¥ä»»æ„è¿”å›ä¸€ä¸ªå€¼å°±è¡Œäº†
    : A1 : A1
  ) 
  : 
  (
    // è½¬æ¢æˆå­—ç¬¦ä¸²åé•¿åº¦ä¸ç›¸ç­‰
    GetStringLen<S1> extends GetMinNumber<GetStringLen<S1>, GetStringLen<S2>> ?
    // S1 é•¿åº¦å°äº S2
    isAllNegative extends false ? B1 : A1 :
    // S1é•¿åº¦å¤§äº S2
    isAllNegative extends false ? A1 : B1
  )


  // åˆ†ä¸ºå››ç§æƒ…å†µ
// 1 A>= 0 B>=0     ===========> æ¯”è¾ƒ length ,è°çš„ length å¤§ è¿”å›è°
// 2 A>0 B<0        ===========> ç›´æ¥è¿”å› A
// 3 A<0 B>0        ===========> ç›´æ¥è¿”å› B
// 4 A<0 B<0        ========== > è°çš„lengthå°ï¼Œå€¼è¶Šå¤§
type Max<A extends number, B extends number> =
IsNegative<A> extends true
? IsNegative<B> extends true
// A < 0 , B < 0
? Compare<GetNegative<A>, GetNegative<B>, true, A, B> : B
: IsNegative<B> extends true ? A : Compare<A, B>



// ç­”æ¡ˆ
type Maximum<T extends number[], M extends number = T[0], First extends boolean = true> =
T['length'] extends 0 ? (
  First extends true ? never : M
) :
T extends [infer A extends number, ...infer B extends number[]] ?
Maximum<B, Max<A, M>, false> : M


// test
type N1 = NumToString<100>
type N2 = NumToString<20>
type S1 = GetStringLen<N1>

// test  GetMaxNumber
type G1 = GetMaxNumber<1, 2, 100, 200> // 200
type G2 = GetMaxNumber<1, 2, 100, 200>  // 200
type G3 = GetMaxNumber<2, 1, -200, -100, true> // -100
type G4 = GetMaxNumber<1, 2, -100, -200, true> // -100
type G5 = GetMaxNumber<1, 1, 10, 10, false> // 10
type G6 = GetMaxNumber<1, 1, 10, 10, false> // 


//test
type A1 = Max<30000000, 20000000> // 30000000
type A2 = Max<20000000, 30000000> // 30000000
type B1 = Max<0, 100000000> // 100000000
type B2 = Max<100000000, 0> // 100000000
type C1 = Max<-10000000000, -20000000000> // -10000000000
type C2 = Max<-20000000000, -10000000000> // -10000000000
type D1 = Max<-20000000, -10000000000000> // -20000000
type D2 = Max<-10000000000000, -20000000> // -20000000
type E1 = Max<-30000000, -30000000> // -20000000
type E2 = Max<-30000000, -30000000> // -20000000

// test
type arr0 = Maximum<[]> // never
type arr1 = Maximum<[-100000, -2000000, -2000000, -150000000]> // -100000
type arr2 = Maximum<[-10, -200000, -2000, -1500000000]> // -10
type arr3 = Maximum<[100000000, 20000, 20000, -150000]> // 100000000
type arr4 = Maximum<[0, -1]> // 0
type arr5 = Maximum<[-1, 1]> // 1

```



**æ€»ç»“ä¸€ä¸‹**

1. å‡ä¸ºæ­£æ•°
   - è½¬æ¢æˆå­—ç¬¦ä¸²æ¯”è¾ƒï¼Œè°çš„é•¿åº¦å¤§ï¼Œå€¼å°±è¶Šå¤§
   - åŒé•¿åº¦ï¼Œå°†å„ä¸ªå­—ç¬¦å¯¹åº”å€¼ï¼Œä»å·¦åˆ°å³é€ä¸€æ¯”è¾ƒï¼ŒåŒä½ç½®å­—ç¬¦å¯¹åº”æ•°å­—è¶Šå¤§ï¼Œå¯¹åº”å€¼è¶Šå¤§ï¼Œå¯ä»¥é€€å‡ºæ¯”è¾ƒäº†
 2. ä¸€æ­£ä¸€è´Ÿ ç›´æ¥è¿”å›æ­£æ•°
 3. å‡ä¸ºè´Ÿæ•°
    - è½¬æ¢æˆå­—ç¬¦ä¸²,è°çš„é•¿åº¦å°ï¼Œå€¼å°±è¶Šå¤§
    - åŒé•¿åº¦ï¼Œå°†å„ä¸ªå­—ç¬¦å¯¹åº”å€¼ï¼Œä»å·¦åˆ°å³é€ä¸€æ¯”è¾ƒï¼ŒåŒä½ç½®å­—ç¬¦å¯¹åº”æ•°å­—è¶Šå°ï¼Œå¯¹åº”å€¼è¶Šå¤§ï¼Œå¯ä»¥é€€å‡ºæ¯”è¾ƒäº†

**ä¸ºä»€ä¹ˆéœ€è¦è½¬æ¢æˆå­—ç¬¦ä¸²ï¼Ÿ**

å½“æ•°å­—å€¼è¶Šå¤§æ—¶ï¼Œé€’å½’æ·±åº¦å°±è¶Šå¤§ï¼Œå‡ºç°æ ˆæº¢å‡ºã€‚

**è½¬æ¢æˆå­—ç¬¦ä¸²æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ**

åªæ¯”è¾ƒé•¿åº¦ï¼Œä¸ä¼šå­˜åœ¨æ·±åº¦é€’å½’ï¼ŒåŒé•¿åº¦æƒ…å†µä¸‹ï¼Œå¯ä»¥ä»å·¦åˆ°å³é€ä¸€æ¯”å¯¹ï¼Œç”±äºæ¯”è¾ƒçš„æ˜¯å•ä¸ªæ•°å­—ï¼Œè¿™ç§æƒ…å†µä¸‹æœ€å¤§ä¹Ÿæ˜¯9ï¼Œä¸ä¼šå­˜åœ¨æ·±åº¦é€’å½’é—®é¢˜



[æœ¬é¢˜è§£ç­”åœ°å€](https://github.com/type-challenges/type-challenges/issues/27595)

// æœªå®Œå¾…ç»­â€¦â€¦





# å››ã€åœ°ç‹±



// æœªå®Œå¾…ç»­â€¦â€¦



# äº”ã€æ€»ç»“



// æœªå®Œå¾…ç»­â€¦â€¦



# å…­ã€ç›¸å…³é“¾æ¥

- [tsè®­ç»ƒè¥:rocket:](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)

- [maxiaobo:rocket:](https://blog.maxiaobo.com.cn/)
